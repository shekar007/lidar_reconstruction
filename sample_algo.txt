#!/usr/bin/env python
import rospy
import math
import random
import numpy as np
import matplotlib.pyplot as plt
from lidar_project.srv import lidar

def generate_coordinates(n, threshold):
    while True:
        x1 = [random.randint(1, 399) for _ in range(n)]
        x2 = [random.randint(1, 399) for _ in range(n)]
        corr_x = np.corrcoef(x1, x2)[0, 1]
        if abs(corr_x) < threshold:
            break

    while True:
        y1 = [random.randint(1, 399) for _ in range(n)]
        y2 = [random.randint(1, 399) for _ in range(n)]
        corr_y = np.corrcoef(y1, y2)[0, 1]
        if abs(corr_y) < threshold:
            break

    coordinates = [(x1[i], y1[i]) for i in range(n)] + [(x2[i], y2[i]) for i in range(n)]
    return coordinates

def lidar_client(centerX, centerY):
    rospy.wait_for_service('scan')
    try:
        lidar_scan = rospy.ServiceProxy('scan', lidar)
        response = lidar_scan(centerX, centerY)
        return response.lidar_array
    except rospy.ServiceException as e:
        print("Service call failed:", str(e))

if __name__ == "__main__":
    
    rospy.init_node('lidar_client')
    count=1
    map_size = 400
    map_image = np.ones((map_size, map_size), dtype=np.uint8) * 255



    n = 100  # Number of coordinates
    threshold = 0.1  # Desired correlation threshold
    coordinates = generate_coordinates(n, threshold)

    
    index =0
    total =0
    while(count<=10):
        centerX, centerY = coordinates[index]
        lidar_data = lidar_client(centerX, centerY)
        if(lidar_data!=None):
            # print("Lidar readings:")
            # print(lidar_data)
            # Lidar scan origin

            # Example lidar_data arra

            # Define map size and resolution
            # Adjust the map size as needed
            resolution = 1  # Adjust the resolution as needed

            

            # Map the lidar data onto the map
            for i in range(0, len(lidar_data), 2):
                angle = lidar_data[i]
                distance = lidar_data[i+1]

                x = int(distance * np.cos(np.radians(angle))) + centerX
                y = int(distance * np.sin(np.radians(angle))) + centerY

                if 0 <= x < map_size and 0 <= y < map_size:
                    map_image[y, x] = 0  # Set the mapped point as black
            count+=1
            index+=1
            total+=1
        else:
            index +=1
            total+=1
            continue
        
    print(total)
    # Save the map as a JPG image
    plt.imsave('map.jpg', map_image, cmap='gray')

    # Display the map
    plt.imshow(map_image, cmap='gray')
    plt.show()







     
    parts = [lidar_data[i:i+36] for i in range(0, len(lidar_data), 36)]
    angle = 0
    for i in parts:
        f = 0
        for j in range(0, len(i)):
            
            d = i[j]
            if(d >=100):
                a = int(d  * np.cos(np.radians(angle))) + centerX
                b = int(d * np.sin(np.radians(angle))) + centerY
                